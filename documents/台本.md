# 私の担当した箇所について

- フロントエンドの一部
- バックエンド
- インフラ
- モデレーション

ざっと上げると上記 3 カテゴリになります。

# フロントエンドの担当箇所の紹介

時間の都合で、かなりざっくりとした説明になります。

## 会員登録

まずはいきなりですが、会員制サイトということで、新規登録画面の説明をしていきます。  
ユーザー名の使用語句チェックを、該当テキストボックスのフォーカスが外れた際にしております。  
こちらの仕組みに関しては後ほどご説明いたします。  
ユーザー ID の重複チェックをリアルタイムに行っていて、重複があればすぐにメッセージを出します。  
メールアドレスの形式検証を行っております。こちら、RFC 違反アドレスに関しては弾くようになっています。  
パスワードは大文字小文字どちらも混ざっている必要があり、それを確認しております。  
登録後は以下のような画像の内容のメールを送信した後にトップ画面へ遷移します。  
![登録完了メール](https://misskey.na2na.dev/media/media/e7df27be-6736-4b77-a5c5-75b231a29fa4.png)

## ログイン機能

サイドメニューのログインのボタンから行うことができます。  
未ログイン状態のトップページ、カスタマイズボタンからもログイン用のポップアップが出てきます。  
ログインに使うID部分に関しては、登録時に設定したIDでも、メールアドレスでもどちらでも可能です。
細かいところなのですが、パスワードのテキストボックスにフォーカスが当たっている場合は Enter キーを押すとログインボタンが押せます。
パスワードを忘れた場合は、リセットを行うことができ、トークンを GET パラメータに付与したメールから操作を開始します。  
なお、トークンの有効期限を 1 時間に設定しています。  
![パスワード再設定](https://misskey.na2na.dev/media/media/2d83c5e1-2f4a-425b-a558-c90edeaab0fe.png)

## メールアドレス変更

登録時に設定したメールアドレスを変更することができます。  
こちらも、メールに記載されたリンクをクリックして、変更を行うことができます。  
![メールアドレス変更](https://misskey.na2na.dev/media/media/b7ea6763-a45b-4db3-af89-dd82d729389e.png)

## トップページ

ライブラリ機能について、公開中であり、なおかつ削除済みでない作品を 20 個ランダムに表示しています。  
今ここで主張している星に関しては後ほどご説明します。  
各作品、クリックしますと作品詳細が表示されます。  
この画面からは、作成者ページへの遷移、自身の作品であれば作品情報編集画面へ遷移、カートへの追加、お気に入りなどが行えます。
では、左上の作者ページへの遷移をしてみましょう。

## 作者ページ

こちらでは、作者の情報と、作品の一覧が表示されます。  
右側に該当作者をお気に入りできるボタンがあり、その下に他のユーザーも含めてお気に入りされた数が表示されます。  
お気に入り登録をすると、数もリアルタイムに反映させることができます。  
それぞれの作品に対するお気に入りも同じような挙動です。  
各作品をクリックした際の挙動は、トップページと同じです。

## マイ作品リスト

続いて、マイ作品リストの説明です。  
その名の通り、自身の作成した作品が新しい順で表示されます。
1 ページあたり 8 件で、ページングが行えます。  
少しだけバックエンドの説明になりますが、こちらの 1 ページ当たりの表示数は可変となっているので、後から変えることも簡単にできます。  
開発中なんかは、1 ページ当たり 4 件でテストしていましたね。

## お気に入り作品リスト

続いて、お気に入り作品リストの説明です。  
お気に入りした作品を一覧で表示します。

## お気に入り作者リスト

お気に入り作者リストの説明です。  
こちらは自身のお気に入りした作者の一覧です。  
リスト表示とタイル表示のどちらかで表示することができ、デフォルトではリスト表示となっております。

## 買い物関係

### カート

作品の詳細や、作成後にカートに入れた後の流れの説明です。  
まずはトップから何かしらの作品をカートに入れてみます。  
右上のカートアイコンの右側に、数字が出てきたことがわかりますでしょうか。  
試しに他の作品も追加して見ましょう。  
また増えましたね。  
次の画面で説明します。  
こちらがカート画面です。  
それぞれの作品と、数量、合計の価格がわかるようになっています。  
数量は 0 以下にはできないような設定となっています。

では、購入手続きへ進んでみましょう。

### 購入確認画面

こちらが購入確認画面です。  
先ほどカート画面で確認できていた、購入対象と金額の情報に加え、配送の日付時間帯の指定から、配送先の指定、支払い方法の指定を行うことができます。  
それぞれの右側にあるアイコンを選択すると、ポップアップウィンドウが表示され、それぞれ編集ができます。

#### 日付指定

指定なし、日時指定、即日発送から選択できます。  
なお、即日発送に関しては、当日の午前 10 時を過ぎてしまいますと選択ができないようになっています。
日時指定については、選択時点から 3 日後以降の日付を選択することができます。  
今回は指定なしを選択します。

#### 住所選択

配送先指定ができます。
郵便番号を入力した後に、住所選択のボタンを押すと、郵便番号から住所を自動で取得してくれます。

#### 支払い方法選択

支払い方法の選択を行います。  
クレジットカードでの支払いと、PayPay での支払いが選択できます。  
クレジットカードについては今回入力検証を作成しておりません。  
今回は PayPay を選択します。

### 決済

全ての項目の設定が終わりましたので、決済に移ります。  
今回は PayPay を選択しましたので、専用のページへ遷移します。  
開発用環境ですので、普通のクライアントでは支払いできません。  
そのため、今回の展示中では disabled を付けて選択できないようにしていました。  
さて、ユーザー操作が済みましたので、リダイレクト待機です。  
はい、購入完了ページへ遷移しましたね。  
以上でおかいものに関する一連の流れは終了となります。  
![購入完了メール](https://misskey.na2na.dev/media/media/ce69ae45-9285-414d-abde-919ccb2d68fc.png)  
このようなメールが送信されます。

### 検索

フロントの説明としては最後になりますが、検索機能の説明です。
右上にある検索窓から行うことができます。  
こちらに表示されておりますように、先頭に@を付与したユーザー ID、先頭に#を付与したハッシュタグ、何も付与せず入力する作品名をそれぞれ混ぜて AND 検索を行うことができます。  
一瞬だけトップ画面に戻りまして、作品詳細を見てみましょう。こちらにハッシュタグがあると思います。  
それぞれリンクになっておりまして、クリックすると検索結果へ飛ぶことができます。  
次に、検索窓を見てください、検索クエリが残るようになっています。  
続いてユーザー検索です。  
@から始まる適当なユーザーを検索します。今回は ulabeler を入力して見ましょう。  
こちら、検索クエリがユーザー ID のみであると判定された場合はユーザーページへリダイレクトするような仕様となっています。  
続いてキーワード検索ですね。  
時計というワードで検索してみます。  
このように表示されました。  
続いてユーザー名も合わせてみましょう  
該当ユーザーの作品のみに絞り込まれましたね  
さらに絞り込んでいきましょう。  
#HAL が付与された作品の検索です。  
このようになりました。  
全ての順番を問わず、ユーザー ID、ハッシュタグ、作品名の 3 種類をごちゃまぜにして検索することができます。

以上でフロントエンドの説明を終了します。  
続いてバックエンドの説明に移ります。

# バックエンド担当箇所の説明

範囲が余りにも大きいため、概要の説明となります。

## バックエンドの設計思想

「全てを API で」を元に、期間や実装コストの実現可能な範囲で可能な限り多くの操作を API でできるようにしました。  
これにより、例えば将来的に「スマホアプリ版も欲しい」といったニーズが出てきた場合にも対応しやすいようにしています。

## 形態素解析を用いた NG ワード判定

形態素解析を用いて、NG ワードを判定します。  
幅広い年代をターゲットとしており、NG ワードの実装は絶対に必要であると判断したため本機能を追加しました。  
これは、形態素解析ライブラリの MeCab を用いて実装しております。  
単純な正規表現を用いた判定に比べ、単語単位での抽出を行うため、誤検出が少ないという特徴があります。
自身の管理しているほかのサーバーで公開している API をそのまま利用しました。

## Git の利用について。

私の作業分に関して、Git を使用して開発を進めました。  
かなり難度の高そうな実験的な物に関しては、1 機能 1 ブランチで開発を行い、実装が済んだら develop ブランチに push していく流れで開発を進めていました。  
![資料11](https://misskey.na2na.dev/media/media/46afd208-30e4-4457-8769-e040da55304f.png)
![資料12](https://misskey.na2na.dev/media/media/dfb84ef1-8f92-45f8-b5fa-e3019ea257a2.png)
GithubActions による自動テストも採用しております。  
![GithubActions](https://misskey.na2na.dev/media/media/0ce2a844-852d-4211-8e3d-8d692be90ee3.png)

## 一部のユーザーアップロード画像について、WebP 形式に変換している点。

一部のユーザーアップロード画像について、WebP 形式に変換しています。
これにより、画像の品質を維持したまま圧倒的に画像の容量を減らすことができます。
今回@ulabeler として準備したアカウントのアイコン画像で言えば、もともと 4,488Byte で S3 に保存されていた画像が、WebP に変換する処理を挟んだことで 1,016Byte になり、およそ 77%の容量削減をすることができました。
ストレージコストを減らすことができるだけでなく、画像読み込み時の通信負荷削減により、ユーザーがより快適に使うことができるようになります。

## サーバーサイドに TypeScript を採用

サーバーサイドに TypeScript を採用しており、ルーティングは全て TypeScript で実装しています。  
これは変数に型を与えることができる、という圧倒的メリットがあり、意図しない型の値の代入を防ぐことができます。  
変数に厳格な型の概念があることによるメリットは Java をはじめとした他言語を見ると理解していただけるかと思います。  
分かりやすいケースで言うと、DB へのデータ格納時を思い浮かべていただけるとわかりやすいかと思います。  
こちらが実際に型の定義をしている画面です。  
TypeScript には型エイリアスという概念があり、乱暴な言い方をすれば型に名前を付けることができます。  
これを活用してテーブルのカラム名と型を事前に定義しておき、insert 前に型を指定して値を入れることで、エラーを防ぐことができます。  
これはごく一部に過ぎませんが、他にもいくつかのメリットがあることから TypeScript を採用しました。

## ESLint の採用

ESLint は、JavaScript/TypeScript のコードをチェックするためのツールです。  
これの採用により、それぞれで差異が出がちな変数の命名規則、インデントなどのコーディング規約を統一することが容易にすることができるようになります。  
複数人での開発時の効率を上げるための環境整備の一環として導入しました。  
VSCodeの既定のフォーマッタとしても指定可能で、大変お世話になりました。

## 検索機能

検索が行われた際の挙動の解説です。  
検索が行われると、まず飛んできた生のクエリを自作のパーサーで都合のいいような形に直すところから始まります。  
次の画像は実行結果です。  
ハッシュタグと、その他に関しては配列に格納されているのがわかるかと思います。  
このように、パース処理を行うことにより、検索ワードがどのような順番でも検索を行うことができるようになります。
![検索パーサー実行結果](https://misskey.na2na.dev/media/media/d61fc5d0-f9a5-48ca-a45c-06f6290b63ee.png)

## 使用ツール、及びライブラリの紹介

- Node.js
- Express (フレームワーク)
- passport.js (認証に用いたパッケージ)
- knex (オブジェクト関係マッピングツール)
- Github Copilot(AI による自動コード提案、及び補完機能)

passport.jsには、OAuthでの認可/認証機能もあるようなので、Googleでログイン、のような機能を付けてみても面白そうだなと思いました。

簡単ではありましたが、以上でバックエンドの説明を終了します。  
続きまして、今回使用しているインフラ関係の説明をさせていただきます。  
これが最後のセクションですので、もう少しばかりお付き合いお願いします。

# インフラ関係

## 構成図

簡単ですが、次の図のような構成となっております。
![構成図](https://misskey.na2na.dev/media/media/e6e35215-0357-4039-9025-1e7865ed272e.jpg)
API サーバ 1 は、NG ワード検出に使っている物です。

## 今回使用したサーバーについて

今回利用したのは Oracle Cloud Infrastructure(以降 OCI と呼びます)の無料枠で借りられるサーバーで、  
ARM アーキテクチャを利用した 4OCPU、メモリが 24GB のサーバーです。  
画像の保存には AWS S3 を利用しています。  
ドメインや S3 も含め、今回はすでに自身の使っているものの一部を割り当てる形で提供しております。  
また、ここには挙げませんでしたが、メールサーバにはさくらのメールサーバを利用しています。

## CDN を利用したコンテンツキャッシュ

サーバとユーザーの中間には CloudFlare を挟んでおります。  
リクエストされたリソースが、CloudFlareのキャッシュに残っていれば、ulablerのサーバーに行く前にそれを返します。
これは、本番サーバーへの負荷軽減に加え、コンテンツキャッシュを利用することで AWS への負荷軽減にも繋がっています。

## AWS S3 の利用

今回の画像保存先として、AWS S3 を利用しております。  
また、S3 へのアクセスには、接続元 IP 制限を施しております。

## メディアプロキシ

S3 へアクセスする際には、メディアプロキシを経由するようにしています。  
S3 への接続元 IP 制限を迂回してアクセスするようになっております。

## データベースの保護

DB の保護のために、今回は 1 時間に 1 回ダンプを取り、GoogleDrive へアップロードするようにしています。  
これもクラウドサービスによるマネージド DB を使えば楽ができるのですが、今回はコスト面を理由にやめることにしています。  
![GoogleDrive](https://misskey.na2na.dev/media/media/763b3b8a-0a27-4e8e-b2eb-a69accf8bd0f.png)

## サーバーへのデプロイ

Github を用いた管理をしているため、簡単です。
まず、`git clone https://~~~~~`をして、npm run build をして、mysql を起動してダンプファイルを流し込めば完了です。  
ただし、今回は systemd を用いた管理をするのでさらにスクリプトを書いています。  
アップデートは簡単で、`git pull && npm run build`をした後に、`sudo systemctl restart 任意の名前`をすれば完了です。

## 管理

異常があれば、Discord に通知が来るようになっております。  
![監視ツール1](https://misskey.na2na.dev/media/media/dc37a121-e26a-4f63-8405-5d6a2f213887.png)  
余談なのですが、監視していると結構面白くて、GETでのみ受け付けるようなAPIにたいしてブラウザからの直アクセスを試みる愉快な方がちょいちょい出ていましたね。  
また、Better Uptimeというサービスを用いたモニタリングサイトも準備しており、こちらでも異常を検知すると、自身のメールアドレスに通知が来るようになっております。  
![監視ツール2](https://misskey.na2na.dev/media/media/7370bc68-4d11-4ef2-8e06-57a5dcafd54a.png)  
また、先にも述べたようにサーバーアプリケーションはsystemdを用いて管理しているので、どちらかで異常を検知した場合もログを確認することができるようになっております。  
![監視](https://misskey.na2na.dev/media/media/53577989-b355-422b-b640-b246ec5c4e99.png)  
また、今回監視していて引っかかったものはこんな感じです。  
![監視1](https://misskey.na2na.dev/media/media/3b5e061f-f812-41a5-9adb-6ce469e2c0d3.png)

大変長くなってしまいましたが、以上で私の担当範囲の説明、および Ulabeler の説明を終わります。ありがとうございました。
